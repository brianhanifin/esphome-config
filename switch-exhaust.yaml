---
# Device: Shelly 1 PM
# Location: Upstairs bathroom in wall
#
substitutions:
  project: Upstairs bathroom exhaust
  id: switch_exhaust
  hostname: switch-exhaust
  ip: 10.0.20.50

  #humidity_reference_sensor: "sensor.upstairs_bathroom_humidity_average_last_24_hours"
  humidity_reference_sensor: "sensor.upstairs_humidity_average"
  default_humidity_delta_start_threshold: "20.0"  # Difference between house humidity and bathroom humidity.
  default_humidity_delta_end_threshold: "2.0"
  remaining_time_duration: "600"                  # 600 seconds = 10 minutes
  user_interrupt_time_duration: "3600"            # 3600 seconds = 1 hour
  max_temp: "70.0"                                # Max power measurement board temperature in °C.
  user_interrupt_enabled: "false"

  <<: !include common/substitutions/gpio/shelly1pm.yaml

<<: !include common/esphome/esp8266.yaml
<<: !include common/common.yaml

globals:
  - id: delta_start_trigger
    type: float
    restore_value: no
    initial_value: $default_humidity_delta_start_threshold

  - id: delta_end_trigger
    type: float
    restore_value: no
    initial_value: $default_humidity_delta_end_threshold

  - id: humidity_delta
    type: float
    restore_value: yes
    initial_value: "0.0"

  - id: remaining_time
    type: int
    restore_value: no
    initial_value: "0"

  - id: user_interrupt_time
    type: int
    restore_value: no
    initial_value: "0"

interval:
  - interval: 5s
    then:
      #- lambda: ESP_LOGD("interval", "diff %.1f > trigger %.1f ", id(humidity_delta), id(delta_end_trigger));

      # When running decrement the user interrupt timer.
      - if:
          condition:
            - lambda: return id(user_interrupt_time) > 0;
          then:
            - script.execute: user_interrupt_time_decrement
          else:
            # When the relay is on.
            - if:
                condition:
                  - switch.is_on: relay
                then:
                  # Restart the remaining time when motion is detected.
                  - if:
                      condition:
                        - binary_sensor.is_on: motion
                      then:
                        # Allow the humidity to warm up the room by stopping fan when humidity begins rising while motion is on.
                        - if:
                            condition:
                              - lambda: return id(humidity_delta) <= id(delta_end_trigger);
                            then:
                              - switch.turn_off: relay
                            else:
                              - script.execute: remaining_time_restart
                      else:
                        - script.execute: remaining_time_decrement

                # When the relay is off.
                else:
                  - script.execute: humidity_trigger_check

      # Update the remaining time.
      - script.execute: update_ui_timers

script:
  - id: humidity_trigger_check
    then:
      # Turn the fan on when the humidity delta is greater than the START trigger and the user interrupt timer is not running.
      - if:
          condition:
            and:
              - lambda: return id(humidity_delta) > id(delta_start_trigger);
              - lambda: return id(user_interrupt_time) == 0;
          then:
            - switch.turn_on: relay

            - if:
                condition:
                  - lambda: return id(diagnostic_last_trigger).state != "HUMIDITY";
                then:
                  - text_sensor.template.publish:
                      id: diagnostic_last_trigger
                      state: HUMIDITY

  - id: remaining_time_decrement
    then:
      # Decrement the remaining time when the humidity delta is lower than the END trigger.
      - if:
          condition:
            and:
              - lambda: return id(humidity_delta) <= id(delta_end_trigger);
              - lambda: return id(remaining_time) > 0;
          then:
            - globals.set:
                id: remaining_time
                value: !lambda return id(remaining_time) -= 5;

            # Turn off the relay when the remaining time reaches zero
            - if:
                condition:
                  - lambda: return id(remaining_time) == 0;
                then:
                  - switch.turn_off: relay

  - id: remaining_time_restart
    then:
      - globals.set:
          id: remaining_time
          value: !lambda return $remaining_time_duration;

      - sensor.template.publish:
          id: remaining_time_ui
          state: !lambda return id(remaining_time);
  
  - id: user_interrupt_time_clear
    then:
      - if:
          condition:
            - lambda: return id(user_interrupt_time) > 0;
          then:
            - globals.set:
                id: user_interrupt_time
                value: !lambda return 0;

            - sensor.template.publish:
                id: user_interrupt_time_ui
                state: !lambda return id(user_interrupt_time) / 60;

  - id: user_interrupt_time_decrement
    then:
      - globals.set:
          id: user_interrupt_time
          value: !lambda return id(user_interrupt_time) -= 5;

  - id: user_interrupt_time_restart
    then:
      # When humidity_delta is greater than end trigger, activate the interrupt timer.
      - if:
          condition:
            and:
              - lambda: return $user_interrupt_enabled;
              - lambda: return id(humidity_delta) > id(delta_end_trigger);
          then:
            - globals.set:
                id: user_interrupt_time
                value: !lambda return $user_interrupt_time_duration;

            - sensor.template.publish:
                id: user_interrupt_time_ui
                state: !lambda return id(user_interrupt_time) / 60;

  - id: update_humidity_delta
    then:
      - globals.set:
          id: humidity_delta
          value: !lambda return id(humidity_now).state - id(humidity_reference).state;

  - id: update_ui_timers
    then:
      # Update the remaining time.
      - if:
          condition:
            - lambda: return id(remaining_time) > 0;
          then:
            - sensor.template.publish:
                id: remaining_time_ui
                state: !lambda return id(remaining_time);

      # Update the user interrupt time.
      - if:
          condition:
            - lambda: return id(user_interrupt_time) > 0;
          then:
            - sensor.template.publish:
                id: user_interrupt_time_ui
                state: !lambda return id(user_interrupt_time) / 60;

binary_sensor:
  # Physical Toggle Switch. Monitor for switch position changes internally. Do not expose to Home Assistant.
  - platform: gpio
    pin:
      number: $button_gpio
    id: button_toggle
    internal: true
    filters:
      - delayed_on_off: 50ms
    on_state:
      - switch.toggle: relay

      - if:
          condition:
            - lambda: return id(diagnostic_last_trigger).state != "PHYSICAL";
          then:
            - text_sensor.template.publish:
                id: diagnostic_last_trigger
                state: PHYSICAL

      - if:
          # When switched on.
          condition:
            binary_sensor.is_on: button_toggle
          then:
            # Clear the interrupt timer.
            - script.execute: user_interrupt_time_clear

  # Use motion detection to keep fan running.
  - platform: homeassistant
    id: motion
    entity_id: binary_sensor.upstairs_bathroom_motion
    on_state:
      - if:
          # Whem motion is detected AND user_interrupt_time is not running.
          condition:
            and:
              - binary_sensor.is_on: motion
              - lambda: return id(user_interrupt_time) == 0;
          then:
            - if:
                condition:
                  switch.is_off: relay
                then:
                  - switch.turn_on: relay

            - if:
                condition:
                  - lambda: return id(diagnostic_last_trigger).state != "MOTION";
                then:
                  - text_sensor.template.publish:
                      id: diagnostic_last_trigger
                      state: MOTION

number:
  - platform: template
    name: "$project humidity delta start trigger"
    id: delta_start_trigger_ui
    icon: "mdi:timer-play"
    entity_category: config
    unit_of_measurement: "%"
    optimistic: true
    initial_value: $default_humidity_delta_start_threshold
    restore_value: true
    min_value: 0.5
    max_value: 30.0
    step: 0.5
    set_action:
      then:
        - globals.set:
            id: delta_start_trigger
            value: !lambda return id(delta_start_trigger_ui).state;

  - platform: template
    name: "$project humidity delta end trigger"
    id: delta_end_trigger_ui
    icon: "mdi:timer-stop"
    entity_category: config
    unit_of_measurement: "%"
    optimistic: true
    initial_value: $default_humidity_delta_end_threshold
    restore_value: true
    min_value: 0.5
    max_value: 15.0
    step: 0.5
    set_action:
      then:
        - globals.set:
            id: delta_end_trigger
            value: !lambda return id(delta_end_trigger_ui).state;

sensor:
  - platform: homeassistant
    id: humidity_reference
    internal: true
    accuracy_decimals: 1
    #entity_id: sensor.upstairs_bathroom_humidity_average_last_24_hours
    #entity_id: sensor.upstairs_temperature_average
    entity_id: $humidity_reference_sensor
    unit_of_measurement: "%"
    on_value:
      then:
        - script.execute: update_humidity_delta

  - platform: homeassistant
    id: humidity_now
    internal: true
    accuracy_decimals: 1
    entity_id: sensor.upstairs_bathroom_humidity
    unit_of_measurement: "%"
    on_value:
      then:
        - script.execute: update_humidity_delta

  - platform: template
    id: humidity_delta_ui
    name: "$project humidity delta"
    accuracy_decimals: 1
    icon: "mdi:delta"
    entity_category: diagnostic
    unit_of_measurement: "%"
    lambda: return id(humidity_delta);

  - platform: template
    id: remaining_time_ui
    name: "$project remaining time"
    icon: "mdi:sort-clock-ascending"
    accuracy_decimals: 0
    entity_category: diagnostic
    unit_of_measurement: "seconds"
    lambda: return id(remaining_time);

  - platform: template
    id: user_interrupt_time_ui
    name: "$project user interrupt time"
    icon: "mdi:sort-clock-ascending"
    accuracy_decimals: 0
    entity_category: diagnostic
    unit_of_measurement: "minutes"
    lambda: return id(user_interrupt_time) / 60;

  ## Power monitoring
  - platform: hlw8012
    cf_pin: GPIO05
    cf1_pin: GPIO13 # not used because it is not available on the 1PM but it is needed to compile
    sel_pin: GPIO14 # not used because it is not available on the 1PM but it is needed to compile
    power:
      name: "$project power"
      id: "shelly1pm_power"
      device_class: power
      state_class: measurement
      unit_of_measurement: W
      accuracy_decimals: 0
      filters:
        # Map from sensor -> measured value
        - calibrate_linear:
            - 0.0 -> 1.0
            - 110.33186 -> 20.62
            - 131.01909 -> 24.32
            - 341.33920 -> 62.08
            - 5561.41553 -> 1000.0
            - 2975.51221 -> 535.7
            - 9612.66309 -> 1720.0
            - 14891.35352 -> 2679.0
        # Make everything below 2W appear as just 0W.
        - lambda: if (x < 2) return 0; else return x;
    update_interval: 60s

  - platform: total_daily_energy
    name: "$project daily energy"
    power_id: "shelly1pm_power"
    device_class: energy
    state_class: total_increasing
    unit_of_measurement: kWh
    filters:
      - multiply: 0.001

  - platform: ntc
    sensor: temp_resistance_reading
    name: "$project temperature"
    accuracy_decimals: 1
    device_class: temperature
    unit_of_measurement: "°C"
    disabled_by_default: true
    entity_category: diagnostic
    calibration:
      b_constant: 3350
      reference_resistance: 10kOhm
      reference_temperature: 298.15K
    on_value_range:
      - above: $max_temp
        then:
          - homeassistant.event:
              event: esphome.overheat
              data:
                title: "$project has overheated."

  - platform: resistance
    id: temp_resistance_reading
    sensor: temp_analog_reading
    configuration: DOWNSTREAM
    resistor: 32kOhm

  - platform: adc
    id: temp_analog_reading
    pin: A0

switch:
  - platform: gpio
    id: relay
    pin: $relay_gpio
    on_turn_on:
      # Start the remaining timer.
      - script.execute: remaining_time_restart
    on_turn_off:
      - globals.set:
          id: remaining_time
          value: "0"

      - sensor.template.publish:
          id: remaining_time_ui
          state: "0"

  - platform: template
    id: virtual_switch
    name: $project
    optimistic: no
    lambda: return (id(relay).state);
    turn_on_action:
      - switch.turn_on: relay

      - if:
          condition:
            - lambda: return id(diagnostic_last_trigger).state != "VIRTUAL";
          then:
            - text_sensor.template.publish:
                id: diagnostic_last_trigger
                state: VIRTUAL

      # Clear the interrupt timer.
      - script.execute: user_interrupt_time_clear

    turn_off_action:
      - switch.turn_off: relay

      # Start the user interrupt timer.
      - script.execute: user_interrupt_time_restart

text_sensor:
  # Trigger states: PHYSICAL, VIRTUAL (UI or voice assistant), MOTION, HUMIDITY
  - platform: template
    id: diagnostic_last_trigger
    name: "$project last trigger"
    disabled_by_default: true
    entity_category: diagnostic

time:
  - platform: homeassistant
    id: homeassistant_time
    timezone: America/Los_Angeles
